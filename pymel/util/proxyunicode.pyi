from typing import Iterable, List, Optional, Tuple, Union


class ProxyUnicode(object):
    # @overload
    # def __init__(self) -> None: ...
    # @overload
    # def __init__(self, o: object) -> None: ...
    # @overload
    # def __init__(self, o: str, encoding: str = ..., errors: str = ...) ->
    # None: ...
    # def capitalize(self) -> str: ...
    def center(self, width: int, fillchar: str = ...) -> str: ...

    # def count(self, x: str) -> int: ...
    # def decode(self, encoding: str = ..., errors: str = ...) -> str: ...
    # def encode(self, encoding: str = ..., errors: str = ...) -> str: ...
    def endswith(self, suffix: Union[str, Tuple[str, ...]], start: int = ...,
                 end: int = ...) -> bool: ...

    # def expandtabs(self, tabsize: int = ...) -> str: ...
    def find(self, sub: str, start: int = ..., end: int = ...) -> int: ...

    def format(self, *args: object, **kwargs: object) -> str: ...

    # def index(self, sub: str, start: int = ..., end: int = ...) -> int: ...
    # def isalnum(self) -> bool: ...
    # def isalpha(self) -> bool: ...
    def isdecimal(self) -> bool: ...

    # def isdigit(self) -> bool: ...
    def isidentifier(self) -> bool: ...

    def islower(self) -> bool: ...

    def isnumeric(self) -> bool: ...

    def isprintable(self) -> bool: ...

    # def isspace(self) -> bool: ...
    # def istitle(self) -> bool: ...
    def isupper(self) -> bool: ...

    def join(self, iterable: Iterable[str]) -> str: ...

    def ljust(self, width: int, fillchar: str = ...) -> str: ...

    def lower(self) -> str: ...

    def lstrip(self, chars: str = ...) -> str: ...

    def partition(self, sep: str) -> Tuple[str, str, str]: ...

    def replace(self, old: str, new: str, count: int = ...) -> str: ...

    def rfind(self, sub: str, start: int = ..., end: int = ...) -> int: ...

    def rindex(self, sub: str, start: int = ..., end: int = ...) -> int: ...

    def rjust(self, width: int, fillchar: str = ...) -> str: ...

    def rpartition(self, sep: str) -> Tuple[str, str, str]: ...

    def rsplit(self, sep: Optional[str] = ..., maxsplit: int = ...) -> List[
        str]: ...

    def rstrip(self, chars: str = ...) -> str: ...

    def split(self, sep: Optional[str] = ..., maxsplit: int = ...) -> List[
        str]: ...

    # def splitlines(self, keepends: bool = ...) -> List[str]: ...
    def startswith(self, prefix: Union[str, Tuple[str, ...]], start: int = ...,
                   end: int = ...) -> bool: ...

    def strip(self, chars: str = ...) -> str: ...

    # def swapcase(self) -> str: ...
    # def title(self) -> str: ...
    # def translate(self, table: Union[Dict[int, Any], str]) -> str: ...
    def upper(self) -> str: ...

    # def zfill(self, width: int) -> str: ...

    # @overload
    # def __getitem__(self, i: int) -> str: ...
    # @overload
    # def __getitem__(self, s: slice) -> str: ...
    # def __getslice__(self, start: int, stop: int) -> str: ...
    def __add__(self, s: str) -> str: ...

    # def __mul__(self, n: int) -> str: ...
    # def __rmul__(self, n: int) -> str: ...
    # def __mod__(self, x: Any) -> str: ...
    def __eq__(self, x: object) -> bool: ...

    def __ne__(self, x: object) -> bool: ...

    def __lt__(self, x: object) -> bool: ...

    def __le__(self, x: object) -> bool: ...

    def __gt__(self, x: object) -> bool: ...

    def __ge__(self, x: object) -> bool: ...

    # def __len__(self) -> int: ...
    # The argument type is incompatible with Sequence
    # def __contains__(self, s: Union[str, bytes]) -> bool: ...  # type: ignore
    # def __iter__(self) -> Iterator[str]: ...
    # def __str__(self) -> str: ...
    # def __repr__(self) -> str: ...
    # def __int__(self) -> int: ...
    # def __float__(self) -> float: ...
    # def __hash__(self) -> int: ...
    # def __getnewargs__(self) -> Tuple[str]: ...
